import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm
import random

# Number of iterations for the Metropolis-Hastings algorithm
number_iter = 100000
# Standard deviation for the proposal distribution
sigma = 0.4
# Parameters for the first Gaussian component: weight, mean, standard deviation
w1, mu1, sigma1 = 0.5, -2, 1
# Parameters for the second Gaussian component: weight, mean, standard deviation
w2, mu2, sigma2 = 0.5, 2, 1

def targetDistribution(x):
    """
    Target distribution: a mixture of two Gaussian distributions
    Args:
        x: The point at which to evaluate the distribution
    Returns:
        Probability density at point x
    """
    return w1 * norm.pdf(x, mu1, sigma1) + w2 * norm.pdf(x, mu2, sigma2)

def transition_kernel_random(x):
    """
    Proposal distribution: generates a new sample from a normal distribution 
    centered at the current point x with standard deviation sigma
    
    Args:
        x: The current state
    Returns:
        A proposed new state
    """
    return np.random.normal(x, sigma)

def transition_kernel(x, y):
    """
    Calculates the probability density of transitioning from state y to state x
    using a Normal distribution centered at y with standard deviation sigma.
    
    This function represents the proposal distribution q(x|y) in the 
    Metropolis-Hastings algorithm, giving the probability density of 
    proposing state x when the current state is y.
    
    Args:
        x: The proposed state
        y: The current state (center of the Normal distribution)
        
    Returns:
        The probability density of the transition according to a Normal distribution
    """
    return norm.pdf(x, y, sigma)

def ratio(x, y):
    """
    Calculate the Metropolis-Hastings acceptance ratio
    
    
    
    Args:
        x: The proposed state
        y: The current state
    Returns:
        The acceptance probability, capped at 1
    """
    # For symmetric proposal (normal distribution), q(current_x|proposed_x) = q(proposed_x|current_x)
    # so these terms cancel out
    a = (targetDistribution(x) * transition_kernel(x,y))/(targetDistribution(y)*transition_kernel(y,x))

    return a if a < 1 else 1


# Initialize the sample list with the starting point
accepted_sample = []
# Generate initial state from a normal distribution
x0 = np.random.normal(0, sigma)
accepted_sample.append(x0)

# Main Metropolis-Hastings algorithm loop
for i in range(number_iter):
    # Generate proposal for next state using normal distribution
    x_next = transition_kernel_random(x0)
    # Generate uniform random number for acceptance test
    uni_number = random.uniform(0, 1)
    # Apply acceptance criterion
    if ratio(x_next, x0) > uni_number:
        # Accept the proposal
        accepted_sample.append(x_next)
        x0 = x_next
    else:
        # Reject the proposal and keep the current state
        accepted_sample.append(x0)


# Create range of x values for plotting the true target distribution
x = np.linspace(-6, 6, 500)
y = targetDistribution(x)

# Create plot
plt.figure(figsize=(8, 5))
# Plot histogram of samples generated by Metropolis-Hastings
plt.hist(accepted_sample, bins=30, density=True, alpha=0.6, color='b', label="Histogram of samples")
# Plot the true target distribution for comparison
plt.plot(x, y, 'r-', lw=2, label="Mixture PDF")

# Add plot formatting
plt.xlabel("x")
plt.ylabel("Density")
plt.title("Histogram of Accepted Samples and Mixture PDF")
plt.legend()
plt.grid()
plt.show()